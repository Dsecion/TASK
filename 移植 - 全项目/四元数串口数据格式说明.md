# 四元数通信帧格式说明

## 通信帧格式

系统通过USART2串口发送符合标准通信协议的四元数姿态数据帧，格式如下：

### 帧结构
```
[帧头][源地址][目标地址][功能码][数据长度][数据内容][和校验][附加校验]
```

### 详细字段定义

| 字段名称 | 长度 | 内容 | 说明 |
|---------|------|------|------|
| **帧头 (HEAD)** | 1字节 | 0xAB | 固定帧头标识 |
| **源地址 (S_ADDR)** | 1字节 | 0x01 | 发送设备ID |
| **目标地址 (D_ADDR)** | 1字节 | 0x02 | 接收设备ID |
| **功能码 (ID)** | 1字节 | 0x10 | 四元数数据功能码 |
| **数据长度 (LEN)** | 2字节 | 0x10 0x00 | 数据区长度（小端序） |
| **数据内容 (DATA)** | 16字节 | 四元数数据 | W,X,Y,Z各4字节浮点数 |
| **和校验 (SUM CHECK)** | 1字节 | 累加校验 | 对前面所有字节累加 |
| **附加校验 (ADD CHECK)** | 1字节 | 异或校验 | 对前面所有字节异或 |

### 数据内容详细说明
- **W分量**: 4字节IEEE 754单精度浮点数
- **X分量**: 4字节IEEE 754单精度浮点数  
- **Y分量**: 4字节IEEE 754单精度浮点数
- **Z分量**: 4字节IEEE 754单精度浮点数

## 数据包示例

### 完整帧数据（24字节）
```
AB 01 02 10 10 00 [W的4字节] [X的4字节] [Y的4字节] [Z的4字节] [SUM] [ADD]
```

### 示例数据解析
假设四元数为 W=1.0, X=0.5, Y=0.25, Z=0.125：

```
AB 01 02 10 10 00 3F 80 00 00 3F 00 00 00 3E 80 00 00 3E 00 00 00 XX YY
```

其中：
- `AB`: 帧头
- `01`: 源地址
- `02`: 目标地址  
- `10`: 功能码
- `10 00`: 数据长度16（小端序）
- `3F 80 00 00`: W=1.0
- `3F 00 00 00`: X=0.5
- `3E 80 00 00`: Y=0.25
- `3E 00 00 00`: Z=0.125
- `XX`: 和校验
- `YY`: 附加校验

## 串口配置
- **波特率**: 115200
- **数据位**: 8位
- **停止位**: 1位
- **校验位**: 无
- **流控制**: 无

## 数据发送频率
- **发送频率**: 约10Hz (每100ms发送一次)
- **控制方式**: 通过OSTimeDly(10)控制

## 校验算法

### 和校验 (SUM CHECK) 和 附加校验 (ADD CHECK)
按照标准通信协议，两个校验在同一个循环中计算：

```c
void CalculateChecksums(uint8_t *data, uint16_t length, uint8_t *sum_check, uint8_t *add_check) {
    uint8_t sumcheck = 0;  // 使用uint8_t确保8位截断
    uint8_t addcheck = 0;
    
    for (uint16_t i = 0; i < length; i++) {
        sumcheck += data[i];  // SUM CHECK: 累加每个字节
        addcheck += sumcheck; // ADD CHECK: 累加sumcheck的中间值
    }
    
    *sum_check = sumcheck;
    *add_check = addcheck;
}
```

### 算法说明
- **SUM CHECK**: 对帧头到数据内容的所有字节进行累加，使用`uint8_t`确保每次加法后只保留8位
- **ADD CHECK**: 对SUM CHECK的中间值进行累加，即每计算一次`sumcheck += data[i]`后，立即执行`addcheck += sumcheck`
- **校验范围**: 从帧头(0xAB)开始到数据内容结束的所有字节

## 接收端解析代码示例 (C语言)
```c
#include <stdio.h>
#include <string.h>

typedef struct {
    uint8_t head;           // 帧头
    uint8_t src_addr;       // 源地址
    uint8_t dst_addr;       // 目标地址
    uint8_t func_id;        // 功能码
    uint16_t data_len;      // 数据长度
    float quaternion[4];    // 四元数数据
    uint8_t sum_check;      // 和校验
    uint8_t add_check;      // 附加校验
} QuaternionFrame;

int parse_quaternion_frame(uint8_t* data, uint16_t length, QuaternionFrame* frame) {
    if (length < 24) return -1;  // 帧长度不足
    
    uint8_t* ptr = data;
    
    // 解析帧头
    if (*ptr != 0xAB) return -2;  // 帧头错误
    frame->head = *ptr++;
    
    // 解析地址和功能码
    frame->src_addr = *ptr++;
    frame->dst_addr = *ptr++;
    frame->func_id = *ptr++;
    
    // 解析数据长度（小端序）
    frame->data_len = *ptr | (*(ptr + 1) << 8);
    ptr += 2;
    
    if (frame->data_len != 16) return -3;  // 数据长度错误
    
    // 解析四元数数据
    memcpy(frame->quaternion, ptr, 16);
    ptr += 16;
    
    // 解析校验
    frame->sum_check = *ptr++;
    frame->add_check = *ptr++;
    
    // 验证校验
    uint8_t calc_sum, calc_add;
    CalculateChecksums(data, 22, &calc_sum, &calc_add);
    
    if (calc_sum != frame->sum_check || calc_add != frame->add_check) {
        return -4;  // 校验错误
    }
    
    return 0;  // 解析成功
}
```

## 接收端解析代码示例 (Python)
```python
import struct

def parse_quaternion_frame(data):
    if len(data) < 24:
        return None, "Frame too short"
    
    # 解析帧头
    if data[0] != 0xAB:
        return None, "Invalid frame header"
    
    # 解析基本信息
    src_addr = data[1]
    dst_addr = data[2]
    func_id = data[3]
    
    # 解析数据长度（小端序）
    data_len = data[4] | (data[5] << 8)
    
    if data_len != 16:
        return None, "Invalid data length"
    
    # 解析四元数数据
    quaternion_data = data[6:22]
    w, x, y, z = struct.unpack('<ffff', quaternion_data)
    
    # 解析校验
    sum_check = data[22]
    add_check = data[23]
    
    # 验证校验
    sumcheck = 0
    addcheck = 0
    for byte in data[:22]:
        sumcheck += byte
        addcheck += sumcheck
    
    sumcheck &= 0xFF  # 确保8位截断
    addcheck &= 0xFF  # 确保8位截断
    
    if sumcheck != sum_check or addcheck != add_check:
        return None, "Checksum error"
    
    return {
        'src_addr': src_addr,
        'dst_addr': dst_addr,
        'func_id': func_id,
        'quaternion': [w, x, y, z]
    }, "Success"
```

## 注意事项
1. **字节序**: 数据长度字段使用小端序
2. **校验范围**: 校验和计算包含帧头到数据内容的所有字节
3. **数据精度**: 四元数使用IEEE 754单精度浮点数格式
4. **帧长度**: 固定24字节，包含所有字段
5. **错误处理**: 接收端应验证帧头、数据长度和校验和
6. **设备ID**: 可根据实际应用修改源地址和目标地址
7. **功能码**: 可根据需要定义不同的功能码
