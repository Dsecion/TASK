


ARM Macro Assembler    Page 1 


    1 00000000         ;*******************************************************
                       *************************************************
    2 00000000         ;                                              uC/OS-II
    3 00000000         ;                                        The Real-Time K
                       ernel
    4 00000000         ;
    5 00000000         ;                    Copyright 1992-2021 Silicon Laborat
                       ories Inc. www.silabs.com
    6 00000000         ;
    7 00000000         ;                                 SPDX-License-Identifie
                       r: APACHE-2.0
    8 00000000         ;
    9 00000000         ;               This software is subject to an open sour
                       ce license and is distributed by
   10 00000000         ;                Silicon Laboratories Inc. pursuant to t
                       he terms of the Apache License,
   11 00000000         ;                    Version 2.0 available at www.apache
                       .org/licenses/LICENSE-2.0.
   12 00000000         ;
   13 00000000         ;*******************************************************
                       *************************************************
   14 00000000         
   15 00000000         ;*******************************************************
                       *************************************************
   16 00000000         ;
   17 00000000         ;                                             ARMv7-M Po
                       rt
   18 00000000         ;
   19 00000000         ; Filename  : os_cpu_a.asm
   20 00000000         ; Version   : V2.93.01
   21 00000000         ;*******************************************************
                       *************************************************
   22 00000000         ; For       : ARMv7-M Cortex-M
   23 00000000         ; Mode      : Thumb-2 ISA
   24 00000000         ; Toolchain : ARM C Compiler
   25 00000000         ;*******************************************************
                       *************************************************
   26 00000000         ; Note(s)   : (1) This port supports the ARM Cortex-M3, 
                       Cortex-M4 and Cortex-M7 architectures.
   27 00000000         ;             (2) It has been tested with the following 
                       Hardware Floating Point Unit.
   28 00000000         ;                 (a) Single-precision: FPv4-SP-D16-M an
                       d FPv5-SP-D16-M
   29 00000000         ;                 (b) Double-precision: FPv5-D16-M
   30 00000000         ;*******************************************************
                       *************************************************
   31 00000000         
   32 00000000         ;*******************************************************
                       *************************************************
   33 00000000         ;                                          PUBLIC FUNCTI
                       ONS
   34 00000000         ;*******************************************************
                       *************************************************
   35 00000000         
   36 00000000                 EXTERN           OSRunning   ; External referenc
                                                            es
   37 00000000                 EXTERN           OSPrioCur
   38 00000000                 EXTERN           OSPrioHighRdy
   39 00000000                 EXTERN           OSTCBCur



ARM Macro Assembler    Page 2 


   40 00000000                 EXTERN           OSTCBHighRdy
   41 00000000                 EXTERN           OSIntExit
   42 00000000                 EXTERN           OSTaskSwHook
   43 00000000                 EXTERN           OS_CPU_ExceptStkBase
   44 00000000                 EXTERN           OS_KA_BASEPRI_Boundary
   45 00000000         
   46 00000000         
   47 00000000                 EXPORT           OSStartHighRdy ; Functions decl
                                                            ared in this file
   48 00000000                 EXPORT           OS_CPU_SR_Save
   49 00000000                 EXPORT           OS_CPU_SR_Restore
   50 00000000                 EXPORT           OSCtxSw
   51 00000000                 EXPORT           OSIntCtxSw
   52 00000000                 EXPORT           PendSV_Handler
   53 00000000                 EXPORT           SystemInit
   54 00000000         
   55 00000000         
   56 00000000                 IF               {FPU} != "SoftVFP"
   57 00000000                 EXPORT           OS_CPU_FP_Reg_Push
   58 00000000                 EXPORT           OS_CPU_FP_Reg_Pop
   59 00000000                 ENDIF
   60 00000000         
   61 00000000         
   62 00000000         ;*******************************************************
                       *************************************************
   63 00000000         ;                                               EQUATES
   64 00000000         ;*******************************************************
                       *************************************************
   65 00000000         
   66 00000000 E000ED04 
                       NVIC_INT_CTRL
                               EQU              0xE000ED04  ; Interrupt control
                                                             state register.
   67 00000000 E000ED22 
                       NVIC_SYSPRI14
                               EQU              0xE000ED22  ; System priority r
                                                            egister (priority 1
                                                            4).
   68 00000000 000000FF 
                       NVIC_PENDSV_PRI
                               EQU              0xFF        ; PendSV priority v
                                                            alue (lowest).
   69 00000000 10000000 
                       NVIC_PENDSVSET
                               EQU              0x10000000  ; Value to trigger 
                                                            PendSV exception.
   70 00000000         
   71 00000000         
   72 00000000         ;*******************************************************
                       *************************************************
   73 00000000         ;                                     CODE GENERATION DI
                       RECTIVES
   74 00000000         ;*******************************************************
                       *************************************************
   75 00000000         
   76 00000000                 AREA             |.text|, CODE, READONLY, ALIGN=
2
   77 00000000                 THUMB
   78 00000000                 REQUIRE8



ARM Macro Assembler    Page 3 


   79 00000000                 PRESERVE8
   80 00000000         
   81 00000000         
   82 00000000         
   83 00000000                 IF               {FPU} != "SoftVFP"
   84 00000000         
   85 00000000         OS_CPU_FP_Reg_Push
   86 00000000 F3EF 8109       MRS              R1, PSP     ; PSP is process st
                                                            ack pointer
   87 00000004 B121            CBZ              R1, OS_CPU_FP_nosave ; Skip FP 
                                                            register save the f
                                                            irst time
   88 00000006         
   89 00000006 ED20 8A10       VSTMDB           R0!, {S16-S31}
   90 0000000A 4962            LDR              R1, =OSTCBCur
   91 0000000C 680A            LDR              R2, [R1]
   92 0000000E 6010            STR              R0, [R2]
   93 00000010         OS_CPU_FP_nosave
   94 00000010 4770            BX               LR
   95 00000012         
   96 00000012                 ENDIF
   97 00000012         
   98 00000012                 IF               {FPU} != "SoftVFP"
   99 00000012         
  100 00000012         OS_CPU_FP_Reg_Pop
  101 00000012 ECB0 8A10       VLDMIA           R0!, {S16-S31}
  102 00000016 4960            LDR              R1, =OSTCBHighRdy
  103 00000018 680A            LDR              R2, [R1]
  104 0000001A 6010            STR              R0, [R2]
  105 0000001C 4770            BX               LR
  106 0000001E         
  107 0000001E                 ENDIF
  108 0000001E         
  109 0000001E         
  110 0000001E         ;*******************************************************
                       *************************************************
  111 0000001E         ;                                   CRITICAL SECTION MET
                       HOD 3 FUNCTIONS
  112 0000001E         ;
  113 0000001E         ; Description : Disable/Enable Kernel aware interrupts b
                       y preserving the state of BASEPRI.  Generally speaking,
  114 0000001E         ;               the state of the BASEPRI interrupt excep
                       tion processing is stored in the local variable
  115 0000001E         ;               'cpu_sr' & Kernel Aware interrupts are t
                       hen disabled ('cpu_sr' is allocated in all functions
  116 0000001E         ;               that need to disable Kernel aware interr
                       upts). The previous BASEPRI interrupt state is restored
  117 0000001E         ;               by copying 'cpu_sr' into the BASEPRI reg
                       ister.
  118 0000001E         ;
  119 0000001E         ; Prototypes  : OS_CPU_SR  OS_CPU_SR_Save   (OS_CPU_SR  
                       new_basepri);
  120 0000001E         ;               void       OS_CPU_SR_Restore(OS_CPU_SR  
                       cpu_sr);
  121 0000001E         ;
  122 0000001E         ;
  123 0000001E         ; Note(s)     : 1) These functions are used in general l
                       ike this:
  124 0000001E         ;



ARM Macro Assembler    Page 4 


  125 0000001E         ;                  void Task (void *p_arg)
  126 0000001E         ;                  {
  127 0000001E         ;                  #if OS_CRITICAL_METHOD == 3          
                       /* Allocate storage for CPU status register  */
  128 0000001E         ;                      OS_CPU_SR  cpu_sr;
  129 0000001E         ;                  #endif
  130 0000001E         ;
  131 0000001E         ;                          :
  132 0000001E         ;                          :
  133 0000001E         ;                      OS_ENTER_CRITICAL();             
                       /* cpu_sr = OS_CPU_SR_Save(new_basepri);     */
  134 0000001E         ;                          :
  135 0000001E         ;                          :
  136 0000001E         ;                      OS_EXIT_CRITICAL();              
                       /* OS_CPU_RestoreSR(cpu_sr);                 */
  137 0000001E         ;                          :
  138 0000001E         ;                          :
  139 0000001E         ;                  }
  140 0000001E         ;
  141 0000001E         ;               2) Increasing priority using a write to 
                       BASEPRI does not take effect immediately.
  142 0000001E         ;                  (a) IMPLICATION  This erratum means t
                       hat the instruction after an MSR to boost BASEPRI
  143 0000001E         ;                      might incorrectly be preempted by
                        an insufficient high priority exception.
  144 0000001E         ;
  145 0000001E         ;                  (b) WORKAROUND  The MSR to boost BASE
                       PRI can be replaced by the following code sequence:
  146 0000001E         ;
  147 0000001E         ;                      CPSID i
  148 0000001E         ;                      MSR to BASEPRI
  149 0000001E         ;                      DSB
  150 0000001E         ;                      ISB
  151 0000001E         ;                      CPSIE i
  152 0000001E         ;*******************************************************
                       *************************************************
  153 0000001E         
  154 0000001E         OS_CPU_SR_Save
  155 0000001E B672            CPSID            I           ; Cortex-M7 errata 
                                                            notice. See Note #2
                                                            
  156 00000020 B402            PUSH             {R1}
  157 00000022 F3EF 8111       MRS              R1, BASEPRI
  158 00000026 F380 8811       MSR              BASEPRI, R0
  159 0000002A F3BF 8F4F       DSB
  160 0000002E F3BF 8F6F       ISB
  161 00000032 4608            MOV              R0, R1
  162 00000034 BC02            POP              {R1}
  163 00000036 B662            CPSIE            I
  164 00000038 4770            BX               LR
  165 0000003A         
  166 0000003A         OS_CPU_SR_Restore
  167 0000003A B672            CPSID            I           ; Cortex-M7 errata 
                                                            notice. See Note #2
                                                            
  168 0000003C F380 8811       MSR              BASEPRI, R0
  169 00000040 F3BF 8F4F       DSB
  170 00000044 F3BF 8F6F       ISB
  171 00000048 B662            CPSIE            I



ARM Macro Assembler    Page 5 


  172 0000004A 4770            BX               LR
  173 0000004C         
  174 0000004C         
  175 0000004C         ;*******************************************************
                       *************************************************
  176 0000004C         ;                                         START MULTITAS
                       KING
  177 0000004C         ;                                      void OSStartHighR
                       dy(void)
  178 0000004C         ;
  179 0000004C         ; Note(s) : 1) This function triggers a PendSV exception
                        (essentially, causes a context switch) to cause
  180 0000004C         ;              the first task to start.
  181 0000004C         ;
  182 0000004C         ;           2) During task execution, PSP is used as the
                        stack pointer.
  183 0000004C         ;              When an exception occurs, the core will s
                       witch to MSP until the exception return.
  184 0000004C         ;
  185 0000004C         ;           3) OSStartHighRdy() MUST:
  186 0000004C         ;              a) Setup PendSV exception priority to low
                       est;
  187 0000004C         ;              b) Set initial PSP to 0, to tell context 
                       switcher this is first run;
  188 0000004C         ;              c) Set the main stack to OS_CPU_ExceptStk
                       Base
  189 0000004C         ;              d) Set OSRunning to TRUE;
  190 0000004C         ;              e) Get current high priority, OSPrioCur =
                        OSPrioHighRdy;
  191 0000004C         ;              f) Get current ready thread TCB, OSTCBCur
                        = OSTCBHighRdy;
  192 0000004C         ;              g) Get new process SP from TCB, SP = OSTC
                       BHighRdy->OSTCBStkPtr;
  193 0000004C         ;              h) Restore R0-R11 and R14 from new proces
                       s stack;
  194 0000004C         ;              i) Enable interrupts (tasks will run with
                        interrupts enabled).
  195 0000004C         ;*******************************************************
                       *************************************************
  196 0000004C         
  197 0000004C         OSStartHighRdy
  198 0000004C B672            CPSID            I           ; Prevent interrupt
                                                            ion during context 
                                                            switch
  199 0000004E 4853            LDR              R0, =NVIC_SYSPRI14 ; Set the Pe
                                                            ndSV exception prio
                                                            rity
  200 00000050 F04F 01FF       LDR              R1, =NVIC_PENDSV_PRI
  201 00000054 7001            STRB             R1, [R0]
  202 00000056         
  203 00000056 2000            MOVS             R0, #0      ; Set the PSP to 0 
                                                            for initial context
                                                             switch call
  204 00000058 F380 8809       MSR              PSP, R0
  205 0000005C         
  206 0000005C 4850            LDR              R0, =OS_CPU_ExceptStkBase ; Ini
                                                            tialize the MSP to 
                                                            the OS_CPU_ExceptSt
                                                            kBase



ARM Macro Assembler    Page 6 


  207 0000005E 6801            LDR              R1, [R0]
  208 00000060 F381 8808       MSR              MSP, R1
  209 00000064         
  210 00000064 F7FF FFFE       BL               OSTaskSwHook ; Call OSTaskSwHoo
                                                            k() for FPU Push & 
                                                            Pop
  211 00000068         
  212 00000068 484E            LDR              R0, =OSRunning 
                                                            ; OSRunning = TRUE
  213 0000006A 2101            MOVS             R1, #1
  214 0000006C 7001            STRB             R1, [R0]
  215 0000006E         
  216 0000006E 484E            LDR              R0, =OSPrioCur ; OSPrioCur = OS
                                                            PrioHighRdy;
  217 00000070 494E            LDR              R1, =OSPrioHighRdy
  218 00000072 780A            LDRB             R2, [R1]
  219 00000074 7002            STRB             R2, [R0]
  220 00000076         
  221 00000076 4847            LDR              R0, =OSTCBCur ; OSTCBCur  = OST
                                                            CBHighRdy;
  222 00000078 4947            LDR              R1, =OSTCBHighRdy
  223 0000007A 680A            LDR              R2, [R1]
  224 0000007C 6002            STR              R2, [R0]
  225 0000007E         
  226 0000007E 6810            LDR              R0, [R2]    ; R0 is new process
                                                             SP; SP = OSTCBHigh
                                                            Rdy->OSTCBStkPtr;
  227 00000080 F380 8809       MSR              PSP, R0     ; Load PSP with new
                                                             process SP
  228 00000084         
  229 00000084 F3EF 8014       MRS              R0, CONTROL
  230 00000088 F040 0002       ORR              R0, R0, #2
  231 0000008C F380 8814       MSR              CONTROL, R0
  232 00000090 F3BF 8F6F       ISB                          ; Sync instruction 
                                                            stream
  233 00000094         
  234 00000094 E8BD 4FF0       LDMFD            SP!, {R4-R11, LR} ; Restore r4-
                                                            11, lr from new pro
                                                            cess stack
  235 00000098 BC0F            LDMFD            SP!, {R0-R3} ; Restore r0, r3
  236 0000009A E8BD 5000       LDMFD            SP!, {R12, LR} 
                                                            ; Load R12 and LR
  237 0000009E BC06            LDMFD            SP!, {R1, R2} ; Load PC and dis
                                                            card xPSR
  238 000000A0 B662            CPSIE            I
  239 000000A2 4708            BX               R1
  240 000000A4         
  241 000000A4         
  242 000000A4         ;*******************************************************
                       *************************************************
  243 000000A4         ;                       PERFORM A CONTEXT SWITCH (From t
                       ask level) - OSCtxSw()
  244 000000A4         ;                   PERFORM A CONTEXT SWITCH (From inter
                       rupt level) - OSIntCtxSw()
  245 000000A4         ;
  246 000000A4         ; Note(s) : 1) OSCtxSw() is called when OS wants to perf
                       orm a task context switch.  This function
  247 000000A4         ;              triggers the PendSV exception which is wh
                       ere the real work is done.



ARM Macro Assembler    Page 7 


  248 000000A4         ;
  249 000000A4         ;           2) OSIntCtxSw() is called by OSIntExit() whe
                       n it determines a context switch is needed as
  250 000000A4         ;              the result of an interrupt.  This functio
                       n simply triggers a PendSV exception which will
  251 000000A4         ;              be handled when there are no more interru
                       pts active and interrupts are enabled.
  252 000000A4         ;*******************************************************
                       *************************************************
  253 000000A4         
  254 000000A4         OSCtxSw
  255 000000A4         OSIntCtxSw
  256 000000A4         
  257 000000A4 4842            LDR              R0, =NVIC_INT_CTRL ; Trigger th
                                                            e PendSV exception 
                                                            (causes context swi
                                                            tch)
  258 000000A6 F04F 5180       LDR              R1, =NVIC_PENDSVSET
  259 000000AA 6001            STR              R1, [R0]
  260 000000AC 4770            BX               LR
  261 000000AE         
  262 000000AE         
  263 000000AE         ;*******************************************************
                       *************************************************
  264 000000AE         ;                                       HANDLE PendSV EX
                       CEPTION
  265 000000AE         ;                                   void OS_CPU_PendSVHa
                       ndler(void)
  266 000000AE         ;
  267 000000AE         ; Note(s) : 1) PendSV is used to cause a context switch.
                         This is a recommended method for performing
  268 000000AE         ;              context switches with Cortex-M.  This is 
                       because the Cortex-M auto-saves half of the
  269 000000AE         ;              processor context on any exception, and r
                       estores same on return from exception.  So only
  270 000000AE         ;              saving of R4-R11 & R14 is required and fi
                       xing up the stack pointers. Using the PendSV exception
  271 000000AE         ;              this way means that context saving and re
                       storing is identical whether it is initiated from
  272 000000AE         ;              a thread or occurs due to an interrupt or
                        exception.
  273 000000AE         ;
  274 000000AE         ;           2) Pseudo-code is:
  275 000000AE         ;              a) Get the process SP
  276 000000AE         ;              b) Save remaining regs r4-r11 & r14 on pr
                       ocess stack;
  277 000000AE         ;              c) Save the process SP in its TCB, OSTCBC
                       ur->OSTCBStkPtr = SP;
  278 000000AE         ;              d) Call OSTaskSwHook();
  279 000000AE         ;              e) Get current high priority, OSPrioCur =
                        OSPrioHighRdy;
  280 000000AE         ;              f) Get current ready thread TCB, OSTCBCur
                        = OSTCBHighRdy;
  281 000000AE         ;              g) Get new process SP from TCB, SP = OSTC
                       BHighRdy->OSTCBStkPtr;
  282 000000AE         ;              h) Restore R4-R11 and R14 from new proces
                       s stack;
  283 000000AE         ;              i) Perform exception return which will re
                       store remaining context.



ARM Macro Assembler    Page 8 


  284 000000AE         ;
  285 000000AE         ;           3) On entry into PendSV handler:
  286 000000AE         ;              a) The following have been saved on the p
                       rocess stack (by processor):
  287 000000AE         ;                 xPSR, PC, LR, R12, R0-R3
  288 000000AE         ;              b) Processor mode is switched to Handler 
                       mode (from Thread mode)
  289 000000AE         ;              c) Stack is Main stack (switched from Pro
                       cess stack)
  290 000000AE         ;              d) OSTCBCur      points to the OS_TCB of 
                       the task to suspend
  291 000000AE         ;                 OSTCBHighRdy  points to the OS_TCB of 
                       the task to resume
  292 000000AE         ;
  293 000000AE         ;           4) Since PendSV is set to lowest priority in
                        the system (by OSStartHighRdy() above), we
  294 000000AE         ;              know that it will only be run when no oth
                       er exception or interrupt is active, and
  295 000000AE         ;              therefore safe to assume that context bei
                       ng switched out was using the process stack (PSP).
  296 000000AE         ;
  297 000000AE         ;           5) Increasing priority using a write to BASE
                       PRI does not take effect immediately.
  298 000000AE         ;              (a) IMPLICATION  This erratum means that 
                       the instruction after an MSR to boost BASEPRI
  299 000000AE         ;                  might incorrectly be preempted by an 
                       insufficient high priority exception.
  300 000000AE         ;
  301 000000AE         ;              (b) WORKAROUND  The MSR to boost BASEPRI 
                       can be replaced by the following code sequence:
  302 000000AE         ;
  303 000000AE         ;                  CPSID i
  304 000000AE         ;                  MSR to BASEPRI
  305 000000AE         ;                  DSB
  306 000000AE         ;                  ISB
  307 000000AE         ;                  CPSIE i
  308 000000AE         ;*******************************************************
                       *************************************************
  309 000000AE         
  310 000000AE         PendSV_Handler
  311 000000AE         ;CPSID   I                                              
                            ; Cortex-M7 errata notice. See Note #5
  312 000000AE         ;MOV32   R2, OS_KA_BASEPRI_Boundary                     
                            ; Set BASEPRI priority level required for exception
                        preemption
  313 000000AE         ;LDR     R1, [R2]
  314 000000AE         ;MSR     BASEPRI, R1
  315 000000AE         ;DSB
  316 000000AE         ;ISB
  317 000000AE         ;CPSIE   I
  318 000000AE         
  319 000000AE F3EF 8009       MRS              R0, PSP     ; PSP is process st
                                                            ack pointer
  320 000000B2 E920 4FF0       STMFD            R0!, {R4-R11, R14} ; Save remai
                                                            ning regs r4-11, R1
                                                            4 on process stack
  321 000000B6         
  322 000000B6 4D37            LDR              R5, =OSTCBCur ; OSTCBCur->OSTCB
                                                            StkPtr = SP;



ARM Macro Assembler    Page 9 


  323 000000B8 6829            LDR              R1, [R5]
  324 000000BA 6008            STR              R0, [R1]    ; R0 is SP of proce
                                                            ss being switched o
                                                            ut
  325 000000BC         
  326 000000BC         ; At this point, entire context of process has been save
                       d
  327 000000BC 4674            MOV              R4, LR      ; Save LR exc_retur
                                                            n value
  328 000000BE F7FF FFFE       BL               OSTaskSwHook ; Call OSTaskSwHoo
                                                            k() for FPU Push & 
                                                            Pop
  329 000000C2         
  330 000000C2 4839            LDR              R0, =OSPrioCur ; OSPrioCur = OS
                                                            PrioHighRdy;
  331 000000C4 4939            LDR              R1, =OSPrioHighRdy
  332 000000C6 780A            LDRB             R2, [R1]
  333 000000C8 7002            STRB             R2, [R0]
  334 000000CA         
  335 000000CA 4933            LDR              R1, =OSTCBHighRdy ; OSTCBCur  =
                                                             OSTCBHighRdy;
  336 000000CC 680A            LDR              R2, [R1]
  337 000000CE 602A            STR              R2, [R5]
  338 000000D0         
  339 000000D0 F044 0E04       ORR              LR,  R4, #0x04 ; Ensure excepti
                                                            on return uses proc
                                                            ess stack
  340 000000D4 6810            LDR              R0,  [R2]   ; R0 is new process
                                                             SP; SP = OSTCBHigh
                                                            Rdy->OSTCBStkPtr;
  341 000000D6 E8B0 4FF0       LDMFD            R0!, {R4-R11, R14} ; Restore r4
                                                            -11, R14 from new p
                                                            rocess stack
  342 000000DA F380 8809       MSR              PSP, R0     ; Load PSP with new
                                                             process SP
  343 000000DE         
  344 000000DE F240 0200 
              F2C0 0200        MOV32            R2, #0      ; Restore BASEPRI p
                                                            riority level to 0
  345 000000E6 B672            CPSID            I
  346 000000E8 F382 8811       MSR              BASEPRI, R2
  347 000000EC F3BF 8F4F       DSB
  348 000000F0 F3BF 8F6F       ISB
  349 000000F4 B662            CPSIE            I
  350 000000F6 4770            BX               LR          ; Exception return 
                                                            will restore remain
                                                            ing context
  351 000000F8         
  352 000000F8 40023800 
                       RCC_BASE
                               EQU              0x40023800
  353 000000F8 40023800 
                       RCC_CR  EQU              RCC_BASE + 0x00
  354 000000F8 40023804 
                       RCC_PLLCFGR
                               EQU              RCC_BASE + 0x04
  355 000000F8 40023808 
                       RCC_CFGR
                               EQU              RCC_BASE + 0x08



ARM Macro Assembler    Page 10 


  356 000000F8 40023830 
                       RCC_AHB1ENR
                               EQU              RCC_BASE + 0x30
  357 000000F8 40023C00 
                       FLASH_ACR
                               EQU              0x40023C00
  358 000000F8 E000E010 
                       SYSTICK_BASE
                               EQU              0xE000E010
  359 000000F8 E000E010 
                       SYSTICK_CTRL
                               EQU              SYSTICK_BASE + 0x00
  360 000000F8 E000E014 
                       SYSTICK_LOAD
                               EQU              SYSTICK_BASE + 0x04
  361 000000F8 E000E018 
                       SYSTICK_VAL
                               EQU              SYSTICK_BASE + 0x08
  362 000000F8         
  363 000000F8 E000ED88 
                       SCB_CPACR
                               EQU              0xE000ED88
  364 000000F8 E000ED20 
                       SCB_SHPR3
                               EQU              0xE000ED20
  365 000000F8         
  366 000000F8         SystemInit
  367 000000F8 482E            LDR              R0, =RCC_CR
  368 000000FA 6801            LDR              R1, [R0]    ; ¶ÁÈ¡µ±Ç°RCC_CRµÄÖ
                                                            µ
  369 000000FC F441 21A0       ORR              R1, R1, #(1 << 16) :or: (1 << 1
8) 
                                                            ; ÆôÓÃHSEON£¨²»Çå³ý
                                                            ÆäËûÎ»£©
  370 00000100         ; ÈôÊ¹ÓÃÍâ²¿Ê±ÖÓÔ´£¬Ìí¼Ó£ºORR R1, R1, #(1 << 18) ; ·ñÔò×
                       ¢ÊÍ´ËÐÐ
  371 00000100 6001            STR              R1, [R0]
  372 00000102         
  373 00000102         Wait_HSE_Ready
  374 00000102 6801            LDR              R1, [R0]
  375 00000104 F411 3F00       TST              R1, #(1 << 17)
  376 00000108 D0FB            BEQ              Wait_HSE_Ready
  377 0000010A         
  378 0000010A         ;---------------------------------------------
  379 0000010A         ; 2. 
  380 0000010A         ;---------------------------------------------
  381 0000010A 482B            LDR              R0, =FLASH_ACR
  382 0000010C F04F 0102       MOV              R1, #0x02
  383 00000110 6001            STR              R1, [R0]
  384 00000112         
  385 00000112         
  386 00000112 482A            LDR              R0, =SCB_CPACR
  387 00000114 6801            LDR              R1, [R0]
  388 00000116 F441 0170       ORR              R1, R1, #(0xF << 20)
  389 0000011A 6001            STR              R1, [R0]
  390 0000011C         ;---------------------------------------------
  391 0000011C         ; 3. 
  392 0000011C         ;---------------------------------------------
  393 0000011C 4828            LDR              R0, =RCC_PLLCFGR



ARM Macro Assembler    Page 11 


  394 0000011E F04F 0100       MOV              R1, #0x00000000
  395 00000122 F041 0108       ORR              R1, R1, #(8 << 0) ; PLLM = 16 (
                                                            bits 5:0)
  396 00000126 F441 41A8       ORR              R1, R1, #(336 << 6) ; PLLN = 33
                                                            6 (bits 14:6)
  397 0000012A F441 3180       ORR              R1, R1, #(1<< 16) 
                                                            ; PLLP = 0b00 
  398 0000012E F441 0180       ORR              R1, R1, #(1 << 22) 
                                                            ; PLLSRC = 1 
  399 00000132 6001            STR              R1, [R0]
  400 00000134         
  401 00000134         ;---------------------------------------------
  402 00000134         ; 4. 
  403 00000134         ;---------------------------------------------
  404 00000134 481F            LDR              R0, =RCC_CR
  405 00000136 6801            LDR              R1, [R0]
  406 00000138 F041 7180       ORR              R1, R1, #(1 << 24)
  407 0000013C 6001            STR              R1, [R0]
  408 0000013E         
  409 0000013E         Wait_PLL_Ready
  410 0000013E 6801            LDR              R1, [R0]
  411 00000140 F011 7F00       TST              R1, #(1 << 25)
  412 00000144 D0FB            BEQ              Wait_PLL_Ready
  413 00000146         
  414 00000146         ;---------------------------------------------
  415 00000146         ; 5. 
  416 00000146         ;---------------------------------------------
  417 00000146 481F            LDR              R0, =RCC_CFGR
  418 00000148 F04F 0100       MOV              R1, #0x00000000
  419 0000014C F041 0100       ORR              R1, R1, #(0 << 4) ; HPRE=0 
  420 00000150 F441 5180       ORR              R1, R1, #(0x4 << 10) 
                                                            ; PPRE1=0b100 
  421 00000154 F041 0100       ORR              R1, R1, #(0 << 13) ; PPRE2=0 
  422 00000158 F041 0102       ORR              R1, R1, #(2 << 0) ; SW=0b10 
  423 0000015C 6001            STR              R1, [R0]
  424 0000015E         
  425 0000015E         Wait_Clock_Switch
  426 0000015E 6801            LDR              R1, [R0]
  427 00000160 F001 020C       AND              R2, R1, #0xC
  428 00000164 2A08            CMP              R2, #0x8
  429 00000166 D1FA            BNE              Wait_Clock_Switch
  430 00000168         
  431 00000168         ;---------------------------------------------
  432 00000168         ; 6. 
  433 00000168         ;---------------------------------------------
  434 00000168         
  435 00000168 4817            LDR              R0, =0xE000E010
  436 0000016A F04F 0100       MOV              R1, #0x00000000
  437 0000016E F041 0105       ORR              R1, #5
  438 00000172 6001            STR              R1, [R0]
  439 00000174         
  440 00000174 4814            LDR              R0, =SYSTICK_BASE
  441 00000176 4915            LDR              R1, =83999
  442 00000178 6041            STR              R1, [R0, #0x04]
  443 0000017A F04F 0100       MOV              R1, #0
  444 0000017E 6081            STR              R1, [R0, #0x08]
  445 00000180 F04F 0107       MOV              R1, #0x07
  446 00000184 6001            STR              R1, [R0, #0x00]
  447 00000186         



ARM Macro Assembler    Page 12 


  448 00000186 4812            LDR              R0,=SCB_SHPR3
  449 00000188 F041 61A0       ORR              R1, #(0x5 << 24)
  450 0000018C 6001            STR              R1, [R0]
  451 0000018E         
  452 0000018E B662            CPSIE            I
  453 00000190         
  454 00000190 4770            BX               LR
  455 00000192         
  456 00000192 00 00           ALIGN                        ; Removes warning[A
                                                            1581W]: added <no_p
                                                            adbytes> of padding
                                                             at <address>
  457 00000194         
  458 00000194                 END
              00000000 
              00000000 
              E000ED22 
              00000000 
              00000000 
              00000000 
              00000000 
              E000ED04 
              40023800 
              40023C00 
              E000ED88 
              40023804 
              40023808 
              E000E010 
              0001481F 
              E000ED20 
Command Line: --debug --xref --diag_suppress=9931 --cpu=Cortex-M4.fp --apcs=int
erwork --depend=.\objects\os_cpu_a.d -o.\objects\os_cpu_a.o -I.\RTE\_Target_1 -
ID:\Keil5\ARM\PACK\Keil\STM32F4xx_DFP\2.17.1\Drivers\CMSIS\Device\ST\STM32F4xx\
Include -ID:\Keil5\ARM\CMSIS\Include --predefine="__EVAL SETA 1" --predefine="_
_UVISION_VERSION SETA 524" --predefine="STM32F401xE SETA 1" --list=.\listings\o
s_cpu_a.lst ports\os_cpu_a.asm



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Relocatable symbols

.text 00000000

Symbol: .text
   Definitions
      At line 76 in file ports\os_cpu_a.asm
   Uses
      None
Comment: .text unused
OSCtxSw 000000A4

Symbol: OSCtxSw
   Definitions
      At line 254 in file ports\os_cpu_a.asm
   Uses
      At line 50 in file ports\os_cpu_a.asm
Comment: OSCtxSw used once
OSIntCtxSw 000000A4

Symbol: OSIntCtxSw
   Definitions
      At line 255 in file ports\os_cpu_a.asm
   Uses
      At line 51 in file ports\os_cpu_a.asm
Comment: OSIntCtxSw used once
OSStartHighRdy 0000004C

Symbol: OSStartHighRdy
   Definitions
      At line 197 in file ports\os_cpu_a.asm
   Uses
      At line 47 in file ports\os_cpu_a.asm
Comment: OSStartHighRdy used once
OS_CPU_FP_Reg_Pop 00000012

Symbol: OS_CPU_FP_Reg_Pop
   Definitions
      At line 100 in file ports\os_cpu_a.asm
   Uses
      At line 58 in file ports\os_cpu_a.asm
Comment: OS_CPU_FP_Reg_Pop used once
OS_CPU_FP_Reg_Push 00000000

Symbol: OS_CPU_FP_Reg_Push
   Definitions
      At line 85 in file ports\os_cpu_a.asm
   Uses
      At line 57 in file ports\os_cpu_a.asm
Comment: OS_CPU_FP_Reg_Push used once
OS_CPU_FP_nosave 00000010

Symbol: OS_CPU_FP_nosave
   Definitions
      At line 93 in file ports\os_cpu_a.asm
   Uses
      At line 87 in file ports\os_cpu_a.asm
Comment: OS_CPU_FP_nosave used once
OS_CPU_SR_Restore 0000003A

Symbol: OS_CPU_SR_Restore



ARM Macro Assembler    Page 2 Alphabetic symbol ordering
Relocatable symbols

   Definitions
      At line 166 in file ports\os_cpu_a.asm
   Uses
      At line 49 in file ports\os_cpu_a.asm
Comment: OS_CPU_SR_Restore used once
OS_CPU_SR_Save 0000001E

Symbol: OS_CPU_SR_Save
   Definitions
      At line 154 in file ports\os_cpu_a.asm
   Uses
      At line 48 in file ports\os_cpu_a.asm
Comment: OS_CPU_SR_Save used once
PendSV_Handler 000000AE

Symbol: PendSV_Handler
   Definitions
      At line 310 in file ports\os_cpu_a.asm
   Uses
      At line 52 in file ports\os_cpu_a.asm
Comment: PendSV_Handler used once
SystemInit 000000F8

Symbol: SystemInit
   Definitions
      At line 366 in file ports\os_cpu_a.asm
   Uses
      At line 53 in file ports\os_cpu_a.asm
Comment: SystemInit used once
Wait_Clock_Switch 0000015E

Symbol: Wait_Clock_Switch
   Definitions
      At line 425 in file ports\os_cpu_a.asm
   Uses
      At line 429 in file ports\os_cpu_a.asm
Comment: Wait_Clock_Switch used once
Wait_HSE_Ready 00000102

Symbol: Wait_HSE_Ready
   Definitions
      At line 373 in file ports\os_cpu_a.asm
   Uses
      At line 376 in file ports\os_cpu_a.asm
Comment: Wait_HSE_Ready used once
Wait_PLL_Ready 0000013E

Symbol: Wait_PLL_Ready
   Definitions
      At line 409 in file ports\os_cpu_a.asm
   Uses
      At line 412 in file ports\os_cpu_a.asm
Comment: Wait_PLL_Ready used once
14 symbols



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Absolute symbols

FLASH_ACR 40023C00

Symbol: FLASH_ACR
   Definitions
      At line 357 in file ports\os_cpu_a.asm
   Uses
      At line 381 in file ports\os_cpu_a.asm
Comment: FLASH_ACR used once
NVIC_INT_CTRL E000ED04

Symbol: NVIC_INT_CTRL
   Definitions
      At line 66 in file ports\os_cpu_a.asm
   Uses
      At line 257 in file ports\os_cpu_a.asm
Comment: NVIC_INT_CTRL used once
NVIC_PENDSVSET 10000000

Symbol: NVIC_PENDSVSET
   Definitions
      At line 69 in file ports\os_cpu_a.asm
   Uses
      At line 258 in file ports\os_cpu_a.asm
Comment: NVIC_PENDSVSET used once
NVIC_PENDSV_PRI 000000FF

Symbol: NVIC_PENDSV_PRI
   Definitions
      At line 68 in file ports\os_cpu_a.asm
   Uses
      At line 200 in file ports\os_cpu_a.asm
Comment: NVIC_PENDSV_PRI used once
NVIC_SYSPRI14 E000ED22

Symbol: NVIC_SYSPRI14
   Definitions
      At line 67 in file ports\os_cpu_a.asm
   Uses
      At line 199 in file ports\os_cpu_a.asm
Comment: NVIC_SYSPRI14 used once
RCC_AHB1ENR 40023830

Symbol: RCC_AHB1ENR
   Definitions
      At line 356 in file ports\os_cpu_a.asm
   Uses
      None
Comment: RCC_AHB1ENR unused
RCC_BASE 40023800

Symbol: RCC_BASE
   Definitions
      At line 352 in file ports\os_cpu_a.asm
   Uses
      At line 353 in file ports\os_cpu_a.asm
      At line 354 in file ports\os_cpu_a.asm
      At line 355 in file ports\os_cpu_a.asm
      At line 356 in file ports\os_cpu_a.asm




ARM Macro Assembler    Page 2 Alphabetic symbol ordering
Absolute symbols

RCC_CFGR 40023808

Symbol: RCC_CFGR
   Definitions
      At line 355 in file ports\os_cpu_a.asm
   Uses
      At line 417 in file ports\os_cpu_a.asm
Comment: RCC_CFGR used once
RCC_CR 40023800

Symbol: RCC_CR
   Definitions
      At line 353 in file ports\os_cpu_a.asm
   Uses
      At line 367 in file ports\os_cpu_a.asm
      At line 404 in file ports\os_cpu_a.asm

RCC_PLLCFGR 40023804

Symbol: RCC_PLLCFGR
   Definitions
      At line 354 in file ports\os_cpu_a.asm
   Uses
      At line 393 in file ports\os_cpu_a.asm
Comment: RCC_PLLCFGR used once
SCB_CPACR E000ED88

Symbol: SCB_CPACR
   Definitions
      At line 363 in file ports\os_cpu_a.asm
   Uses
      At line 386 in file ports\os_cpu_a.asm
Comment: SCB_CPACR used once
SCB_SHPR3 E000ED20

Symbol: SCB_SHPR3
   Definitions
      At line 364 in file ports\os_cpu_a.asm
   Uses
      At line 448 in file ports\os_cpu_a.asm
Comment: SCB_SHPR3 used once
SYSTICK_BASE E000E010

Symbol: SYSTICK_BASE
   Definitions
      At line 358 in file ports\os_cpu_a.asm
   Uses
      At line 359 in file ports\os_cpu_a.asm
      At line 360 in file ports\os_cpu_a.asm
      At line 361 in file ports\os_cpu_a.asm
      At line 440 in file ports\os_cpu_a.asm

SYSTICK_CTRL E000E010

Symbol: SYSTICK_CTRL
   Definitions
      At line 359 in file ports\os_cpu_a.asm
   Uses
      None



ARM Macro Assembler    Page 3 Alphabetic symbol ordering
Absolute symbols

Comment: SYSTICK_CTRL unused
SYSTICK_LOAD E000E014

Symbol: SYSTICK_LOAD
   Definitions
      At line 360 in file ports\os_cpu_a.asm
   Uses
      None
Comment: SYSTICK_LOAD unused
SYSTICK_VAL E000E018

Symbol: SYSTICK_VAL
   Definitions
      At line 361 in file ports\os_cpu_a.asm
   Uses
      None
Comment: SYSTICK_VAL unused
16 symbols



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
External symbols

OSIntExit 00000000

Symbol: OSIntExit
   Definitions
      At line 41 in file ports\os_cpu_a.asm
   Uses
      None
Comment: OSIntExit unused
OSPrioCur 00000000

Symbol: OSPrioCur
   Definitions
      At line 37 in file ports\os_cpu_a.asm
   Uses
      At line 216 in file ports\os_cpu_a.asm
      At line 330 in file ports\os_cpu_a.asm

OSPrioHighRdy 00000000

Symbol: OSPrioHighRdy
   Definitions
      At line 38 in file ports\os_cpu_a.asm
   Uses
      At line 217 in file ports\os_cpu_a.asm
      At line 331 in file ports\os_cpu_a.asm

OSRunning 00000000

Symbol: OSRunning
   Definitions
      At line 36 in file ports\os_cpu_a.asm
   Uses
      At line 212 in file ports\os_cpu_a.asm
Comment: OSRunning used once
OSTCBCur 00000000

Symbol: OSTCBCur
   Definitions
      At line 39 in file ports\os_cpu_a.asm
   Uses
      At line 90 in file ports\os_cpu_a.asm
      At line 221 in file ports\os_cpu_a.asm
      At line 322 in file ports\os_cpu_a.asm

OSTCBHighRdy 00000000

Symbol: OSTCBHighRdy
   Definitions
      At line 40 in file ports\os_cpu_a.asm
   Uses
      At line 102 in file ports\os_cpu_a.asm
      At line 222 in file ports\os_cpu_a.asm
      At line 335 in file ports\os_cpu_a.asm

OSTaskSwHook 00000000

Symbol: OSTaskSwHook
   Definitions
      At line 42 in file ports\os_cpu_a.asm



ARM Macro Assembler    Page 2 Alphabetic symbol ordering
External symbols

   Uses
      At line 210 in file ports\os_cpu_a.asm
      At line 328 in file ports\os_cpu_a.asm

OS_CPU_ExceptStkBase 00000000

Symbol: OS_CPU_ExceptStkBase
   Definitions
      At line 43 in file ports\os_cpu_a.asm
   Uses
      At line 206 in file ports\os_cpu_a.asm
Comment: OS_CPU_ExceptStkBase used once
OS_KA_BASEPRI_Boundary 00000000

Symbol: OS_KA_BASEPRI_Boundary
   Definitions
      At line 44 in file ports\os_cpu_a.asm
   Uses
      None
Comment: OS_KA_BASEPRI_Boundary unused
9 symbols
375 symbols in table
